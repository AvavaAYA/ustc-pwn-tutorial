# PWN

`pwn` 引申自单词 `own`，在本门课程中特指“二进制漏洞利用”。

> [!TIP]
> 主流的 `pwn` 题一般符合这样的模型：
> - 一个含有漏洞的二进制程序，运行在一台出题者提供的远程服务器上，解题者通过远程连接，和服务器上的这个程序收发数据（这种数据一般常常标准输入输出来进行交互，例如常用的 `printf` 等等）。解题者通过发送一些构造好的数据，触发服务器上的漏洞，在服务器上执jj行恶意代码，获得 `flag` 信息。

同时，出题者一般会提供这个二进制程序（有些题目中会提供代码），供解题者在本地进行静态漏洞分析和动态调试。

因此，`pwn` 题的大体思想是，在本地分析程序漏洞，并去分析和攻击远程的动态运行环境。所以最基础的一步是在本地进行静态分析。

实际上 `pwn` 的过程就是攻击者**扩大对程序控制范围**的过程：先通过诸如 `fuzz` 或静态分析等手段找到程序漏洞所在，阅读源码或逆向思考可能的利用方式，接着控制用户输入触发漏洞来控制程序的内存布局，再借助精巧的布置绕过层层保护以获得程序执行流程的控制权，最终实现任意代码执行或泄露敏感文件等目标。

上面的利用思路并不局限与课程或比赛题目中，现实世界中的二进制漏洞发现及利用也是类似的过程。

现在无论是 `CTF` 比赛中还是现实场景下，`pwn` 所涵盖的知识范围都非常广泛，也很难在一两节课的时间内速成，这份教材旨在给初学者构建一个更清晰友善的学习框架，同时也会结合一些进阶的内容供感兴趣的同学研究。

---

# 目录

0. [[准备工作]]
1. [[基础 ROP]]
2. [[格式化字符串]]
3. [[堆]]
4. [[Linux 内核]]
5. [[浏览器引擎]]